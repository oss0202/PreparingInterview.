## 인코딩과 디코딩
- 컴퓨터는 문자를 인식할 수 없기 때문에 숫자로 변환되어 저장된다. 변환해주기 위해서는 기준이 
있어야 하는데 이것을 문자코드라고 하며 대표적으로 아스키(ASCII)코드 또는 유니코드가 있다. 

### 인코딩(Encoding)
- 사람이 인지하지 못하고 컴퓨터가 이해할 수 있도록 바꿔주는 것
- 문자(문자열)을 바이트형식으로 변환

### 디코딩(Decoding)
- 바이트형식을 문자(문자열)로 변환

### 아스키(ASCII)코드
- 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계
- 1바이트를 구성하는 8비트 중에서 7비트만 사용하고 1비트는 통신 에러 검출을 위해 사용
- 2바이트 이상의 코드를 표현할 수 없다.
  - 영어 말고 다른 언어 문자는 표현할 수 없다.

### 유니코드(Unicode)
- 컴퓨터가 세상에 나왔을 때는 '영어'와 몇가지 '특수문자'만 사용했고 이를 저장하기 위해서는 1 byte면 충분했다.(0~255)
시간이 플러 다른 국가 사람들이 컴퓨터를 이용하다보니 자국어도 컴퓨터로 표시하고 싶어졌다. 그래서 1 byte안에 임의대로 알파벳대신 자기나라 글자를 할당해서 사용하고 있었다.
그러나 네트워크가 발전하여 다른 사람 홈페이지를 들어가면 글자가 깨지고 만다. 그리하여 국제적으로 전세계 언어를 표시할 수 있는 표준코드인 유니코드(Unicode)를 만들었다.
- 포함시키고자 하는 문자 집합을 정의하였는데 이것을 문자 셋 또는 캐릭터 셋(character set)이라고 한다.
또한 이것을 UTf(Unicode Transformation Format) 이라고 하며 여기에 번호를 붙인 것이 유니코드 인코딩이다.
- UTF-8 : 하나의 문자를 1~4바이트의 가변길이로 표현. 1바이트 영역은 ASCII코드와 하위 호환되며 ASCII코드의 128개 문자 집합은 UTF-8과 동일하게 호환됨. 현재 인터넷에서 가장 많이 쓰이는 인코딩이며 뛰어난 크로스플랫폼 호환성도 갖고 있음

## 네트워크 계층
- 네트워크 계층은 ***OSI 7 Layer***와 ***TCP/IP의 4 Layer***가 있다.
- ****기본 용어****
  - 노드(Node) : 컴퓨터 네트워크 상에 연결된 장치
  - 호스트(Host) : 고유 IP 주소를 가진 노드
  - 홉(Hop) : 한 노드에서 다음 노드간 거리의 단위
  - 프로토콜(Protocol) : 데이터 통신의 규약
  - 라우팅(Routing) : 어떤 네트워크 안에서 통신 데이터를 보낼 때 최적의 경로를 선택하는 과정
  - 라우터(Router) : 패킷의 위치를 추출하여, 그 위치에 대한 최적의 경로를 지정하며, 이 경로를 따라 데이터 패킷을 다음 장치로 전향시키는 장치
    - 패킷(Packet) : 컴퓨터 네트워크에서 데이터를 주고받을 때 정해놓은 규칙



## HTTP vs HTTPS
### HTTP ( Hyper Text Transfer Protocol ) 
- HTTP는 인터넷 상에서 데이터를 주고받기 위한 서버/클라이언트 모델을 따르는 프로토콜
- 클라이언트가 서버에서 요청을 보내면 서버는 응답을 보냄으로써, 데이터를 교환
- HTTP는 ***비연결성*** 및 ***무상태성*** 이라는 특징을 가지고 있다.
  - HTTP는 요청에 대한 응답을 처리하게 되면 연결을 끊어버린다. 
  - 따라서 클라이언트에 대한 이전의 상태 정보 및 현재 통신의 상태가 남아있지 않다.
- 서버가 다수의 클라이언트와 연결을 계속 유지한다면, 이에 따른 자원 낭비가 심해진다. 비연결성 및 무상태성의
 특징을 가진다면 ***불필요한 자원 낭비를 줄일 수 있다는 장점***이 있다.
- 그러나 ***서버는 클라이언트를 식별할 수 없다는 단점***이 존재한다.
- 로그인을 하더라도 다음 요청에서는 해당 클라이언트를 기억하지 못해, 또 로그인을 행하는 문제가 발생한다.
  - 브라우저에서 새로고침을 누를 때마다 로그인을 해야하는 상황
- 우리가 사용하고 있는 웹 사이트들의 경우, 한 번 로그인 하면 다시 로그인할 필요 없이 여러 페이지를
돌아다니며 다양한 기능들을 이용할 수 있다. 심지어는 브라우저를 껏다 켜도 로그인이 유지가 되기도 한다.
  - HTTP의 비연결성 및 무상태성 특징을 보완한 기술인 Cookie와 Session 덕분이다.
- 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동
- HTTP의 문제
  - 암호화 기능 없음
    - 단순 text형식으로 주고받기 때문에, 중간에 누군가가 신호를 가로챈다면 내용이 그대로 노출
  - 신뢰할 수 있는 사이트인지 확인 불가
    - 통신하려는 사이트를 따로 확인하는 작업이 없어 다른 사이트가 통신하려는 사이트로 위장가능
  - 통신 내용 변경 가능
    - 요청을 보낸 곳과 받은 곳의 리소스가 정확히 일치하는지 확인할 수 없음
    - 누군가가 중간에 데이터를 악의적으로 변조한다면 정확한 데이터를 주고받을 수 없게됨

### HTTPS
- HTTP + S(over Secure socket layers) : 보안이 강화된 HTTP
  - SSL(Secure Socket Layer) = TLS(Transport Layer Security)
  - HTTP에 SSL이 첨가된 방식으로 주고 받는 정보가 암호화되어 보안성이 강화된 방식
<br>![https](../img/https.img) 


## 쿠키(Cookie), 세션(Session), JWT
### 인증
- 프론트엔드에서 '인증'은 로그인, 회원가입 등 도입부분에서 사용한다. 서버세 '인증'은 모든 api 요청에 대해 사용자를 확인하는 작업이다.
- HTTP는 connectionless(클라이언트가 요청한 후 응답을 받으면 연결을 끊음),
 stateless(통신이 끝나면 상태를 유지하지 않음)을 가지고 있기 때문에 서버는 클라이언트가 누구인지 확인해야한다. 그래서 HTTP header에
 인증 수단을 넣어 요청을 보낸다.

### 계정 정보를 요청 헤더에 넣는 방식
- 계정정보 자체를 헤더에 담는다. 인증을 테스트할 때 빠르게 시도해 볼 수 있지만 보안에 취약하다.
- 요청이 올 때마다 서버는 전달받은 데이터로 해당 유저가 맞는지 검증해야 하므로 비효율 적이다.

## 쿠키/ 세션 방식
- 쿠키와 세션은 서버의 세션과 사용자 쿠키를 기반으로 하는 인증 방식이다.

### 쿠키(Cookie)
- **클라이언트 로컬**에 저장하는 작은 데이터 파일
```http response
MockHttpServletResponse:
           Status = 200
          Headers = [Set-Cookie:"userName=kevin", "password=abc123"]
```
- key = value 형태
- 사용자에게 발급된 세션 ID를 저장
- 사용자인증이 유효한 시간을 명시할 수 있으며, 유효시간이 정해지면 브라우저가 종료되어도 인증이 유지된다. 장바구니, 24시간 동안 창 띄위지 않기 등에 사용
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 request시에 request header에 넣어서 자동으로 서버에 전송한다.
```http request
MockHttpServletRequest:
      HTTP Method = GET
      Request URI = /user/my/edit
          Headers = [Cookie:"userName=kevin"; "password=abc123"]
```
 
- **장점**
  - 서버의 저장공간 절약
- **단점**
  - 보안에 취약하다.
    - 요청 시 쿠키의 값을 그대로 보낸다.
    - 유출 및 조작 당할 위험이 존재한다.
  - 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.
  - 웹 브라우저마다 쿠키에 대한 자원 형태가 다르게 때문에 브라우저간 공유가 불가능하다.
  - 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.

### 세션(Session)
- **서버**에서 가지고 있는 정보
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며, 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.
- 세션 유효 시간을 설정할 수 있지만, 유효 시간 전이라도 브라우저가 꺼지면 세션도 만료된다.
- 쿠키보다 보안에 좋지만, 사용자가 많아지면 서버 메모리를 많이 차지한다.
- **장점**
  - 어느정도 보안 유지
    - 최초 접속 떄를 제외하고 SessionID만 사용
  - 큰 허용 용량
    - 서버 용량이 충분할 경우 저장 개수나 용량 제한 없음
  - 서버에 저장
    - 클라이언트의 웹 브라우저에 의존하지 않는다.
  - 데이터를 Hash Table에 저장, 한 번에 많은 정보를 하나의 세션 객체에 저장가능
  - SessionID만 보내므로, 세션의 크기가 커도 네트워크 부하가 거의 없음
- **단점**
  - 서버에 부하
    - 서버에 데이터를 저장하므로 세션 양이 많아질수록 서버에 부하가 커짐

### 쿠키/ 세션의 차이점
|특징|쿠키|세션|
|:----:|:---|:---|
|저장위치|브라우저|서버
|보안|낮음|높음
|속도|빠름|느림
|라이프사이클|설정해둔 유효시간만큼|브라우저 종료시 만료
※ 캐시는 정적 파일을 브라우저에 저장해놓고 사용하는 것

## 쿠키(Cookie) & 세션(Session) 기반 인증
- 쿠키를 통해 클라이언트의 상태를 유지시킬 수 있었지만, 가장 큰 단점은 쿠키가
유출 및 조작 당할 위험이 존재한다는 것이다. 개인정보를 HTTP로 주고 받는 것은 위험하다.
- 세션은 비밀번호 등 클라이언트의 인증 정보를 쿠키가 아닌 서버 측에 저장하고 관리한다.
```http response
HTTP/1.1 200
Set-Cookie: JSESSIONID=FDB5E30BF20045E8A9AAFC788383680C;
```
- 서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 떄, 인증 정보는 서버에 저장하고 클라이언트 식별자인 JSESSIONID를 쿠키에 담는다.
- 이후 클라이언트는 요청을 보낼 때마다, JSESSIONID 쿠키를 함께 보낸다.
- 서버는 JSESSIONID 유효서을 판별해 클라이언트를 식별한다.
- **장단점**
  - 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않는다.
    - 해커가 이를 중간에 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재한다
  - 각 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원정보를 확인할 필요가 없다.
  - 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.

### 인증순서
![cookie_session](../img/cookie_session.img)
- 출처
  1. 클라이언트가 로그인을 위해 정보를 서버에 전달한다.
  2. 전달받은 정보로 회원 DB와 비교해 사용자를 확인한다.
  3. 로그인 성공 시 사용자들이 식별할 수 있는 고유한 **세션 ID**를
  생성해 세션 저장소(DB나 메모리, 보통 redis를 많이 사용)에 저장한다.
  4. 세션 ID를 응답에 담아보내면 클라이언트는 해당 값을 ***쿠키***에 저장한다.
  5. 이후 요청에는 ***헤더에 쿠키를 실어서*** 전달한다.
  6. 서버는 쿠키를 받아 세션 저장소에 저장된 세션 ID인지 확인하고, 유요한 쿠키일 경우 요청받은 데이터를 반환한다.


## JWT(Json Web Token)
JWT는 인증에 피요한 정보들을 암호화시킨 토큰을 의미한다. Access Toke을 HTTP 헤더에 실어 서버로 보낸다.
쿠키/세션방식은 세셔 저장소가 필요하기 때문에 멤리 과부하가 생길 수 있지만, JWT 방식은 서버 리소스를 사용하지 않는다.

###형식###
![jwt_total](../img/jwt_total.img)
JWT는 .을 구분자로 나누어지는 세 가지 문자열의 조합이다.
실제 디코딩된 JWT는 다음과 같은 구조를 지닌다.

- Header
  - ![jwt_header](../img/jwt_header.img)
  - 정보를 암호화할 방식(alg), 타입(type) 등
- Payload
  - ![jwt_payload](../img/jwt_payload.img)
  - 서버에서 보낼 데이터, 일반적으로 유저 고유 ID 값, 유효 기간이 들어간다.
  - 쉽게 디코딩이 가능하므로 민감한 정보는 넣지않는다.
  - key-value 형식으로 이루어진 한 쌍의 정보를 Clain이라고 칭한다.
- Verify Signature
  - ![jwt_signature](../img/jwt_signature.img)
  - Base64 방식으로 인코딩한 Header, Payload를 더한 뒤 SECRET KEY로 해싱하여 생성한다.
  - Header와 Payload는 단순히 인코딩된 값이기 때문에 제 3자가 복호화 및 조작할 수 있지만, Signature는 서버 측에서 관리하는 비밀키가
유출되지 않는 이상 복호화할 수 없다.
  - Signature는 토큰의 위변호 여부를 화인하는데 사용된다.

### 인증순서
![jwt](../img/jwt.img)
- 출처
  1. 사용자 로그인
  2. 서버에서 계정정보를 읽어 사용자를 확인한 후, 사용자의 고유한 ID 값을 부여하고 기타 정보와 함께 Payload에 넣음
  3. JWT 토큰 유효기간 설정
  4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급한다.
  5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
  6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효 기간을 확인한다.
  7. 검증이 완료되면 Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

### 장점
1. Header와 Payload를 가지고 Signature를 생성하므로 데이터 위조변조를 막을 수 있다.
2. 인증 정보에 대한 별도의 저장소가 필요없다.
3. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
4. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태가 된다.
5. 확장성이 우수하다.
6. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
7. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹 서비스에서도 로그인을 할 수 있다.
8. 모바일 어플리케이션 환경에서도 잘 동작한다.

### 단점
1. 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해진다.
2. Payload 자체는 암호화되지 않기 떄문에 유저의 중요한 정보는 담을 수 없다.
3. 토큰을 탈취당하면 대처하기 어렵다.
4. 토큰은 한 번 발급되면 유효기간이 만료될 때 까지 계속 사용이 가능하기 때문이다.
5. 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키/세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있다.

## 인증(Authentication)과 인가(Authorization)
- 인증
  - 보호된 리소스에 접근하는 것을 허용하기 이전에 **등록된 유저의 신원을 입증(validation)** 하는 과정
- 인가
  - 요청된 리소스에 접근할 수 있는 **권한이 있는 인증된 유저인지 입증(validating)** 하는 과정
